<!DOCTYPE html>                               
<html>    
  <head>   
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Bem vindo!</title>                           
  </head>                        

  <body>
    <header>                                  
    
      <div class="container">                                                                                                
        <!--<h4 style="color:#009900">$service glusterfs-server start</h4>--><p><code><pre><img align="left" width="140px" height="140px" src="http://i.imgur.com/px7vvyw.jpg"></img>
        <h3 align="middle">Rodolfo Cr</h3><h3 align="middle">Eng. Computação<br><br>rodolfocaserib@gmail.com<br></h3><br><br><h5 align="left" "style="color:#880000"><a href="http://rodcaseribe.github.io/"><img width="40px" height="40px" src="http://icons.iconarchive.com/icons/social-media-icons/social-buntings/512/Github-icon.png"></img>Início</a></h5></pre></code></p>
        
        
      </div>  
    </header>
    <div class="container">
      <section id="main_content">
        <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link">Brute Force em Apache autenticado:</span></a></h3>

<p>Nessa pesquisa procuro uma maneira alternativa de se contornar a autenticação do apache, usado em antenas, em webcam e servidores com a finalidade de proteger e colocar uma barreira a mais antes de um formulário também autenticado.

Existem formas com Burp Suite entre outros softwares, porém utilizando interceptação, uma forma não muito prática e eficaz pra Wordlists grandes.
Em /etc/apache2/sites-availables/00-default.conf ou /etc/apache2/default-server.conf
		<pre><code><Directory "/srv/www/htdocs/ok">

        Options Indexes FollowSymLinks MultiViews ExecCGI
        #Allow from all
        AuthType Basic
        AuthName "ACESSO RESTRITO !! .. Sorry :("
        AuthUserFile "/usr/local/bin/.htpasswd"
        Require valid-user
</Directory></code></pre>		
</p>

<br><br>
<a href="http://www.roothc.com.br"><img align="center" width="600px" height="150px" src="http://www.roothc.com.br/wp-content/uploads/2014/03/roothc-2.png"></img></a>
<!--<p>O Facebook armazena em código fonte quem visualiza seu perfil ou mesmo quem conversa com você também é armazenado, independente se você está em sua página ou em qualquer página do Facebook.<br>
Todas as páginas do Facebook são dinâmicas, fazendo uma pesquisa como páginas estáticas como são a maioria.</p>
<pre><code>
var a = document.body.textContent;var n = a.substring(531000,600000);
console.log(n);
var a = document.body.textContent;var n = a.substring(388500,389000);
console.log(n);
var a = document.body.textContent;var n = a.substring(255210,255480);
console.log(n);
var a = document.body.textContent;var n = a.substring(219810,220110);
console.log(n);
var a = document.body.textContent;var n = a.substring(220490,220890);
console.log(n);
</code></pre>
<p>Não rolou, não pude achar um ponto único que pudesse ser fixo em todas as páginas, então fiz um "Search" e capturando todo o conteúdo do body.<br></p>
<pre><code>var a = document.body.textContent;<br>
var n = a.search("InitialChatFriendsList");</code></pre>
<p>Analisando o tamanho do corpo restante:</p>
<pre><code>
var a = document.body.textContent;
var n = a.search("InitialChatFriendsList");
	for(var i=37; i<300; i++){
		console.log(a[n+i]);
	}
</code></pre>
<p>e tratei os pontos seguintes da cadeia como elementos estáticos dentro de um "For" mesmo.</p></h5></h5>
<pre><code>for(var i=37; i<38; i++){}
</code></pre>
<p>Adicionei algumas variáveis pra quem quiser injetar html com Document.write e tratar como elementos de Array, e adicionar separadores.</p>
<pre><code>var add = "'";
var par1 = "]";
var par2 = '"'; 
var par3 = ';';</code></pre>
<p>Fiz um incremento começando na posição 37 terminando em 38 em InitialChatFriendsList.
</p>
<pre><code>var z =(a[n+i]+a[n+i+1]+a[n+i+2]+a[n+i+3]+a[n+i+4]+a[n+i+5]+a[n+i+6]+a[n+i+7]+a[n+i+8]+a[n+i+9]+a[n+i+10]+a[n+i+11]+a[n+i+12]+a[n+i+13]+a[n+i+14]+a[n+i+15]+a[n+i+16]+a[n+i+17]+a[n+i+18]+a[n+i+19]+a[n+i+20]+a[n+i+21]+a[n+i+22]+a[n+i+23]+a[n+i+24]+a[n+i+25]+a[n+i+26]+a[n+i+27]+a[n+i+28]+a[n+i+29]+a[n+i+30]+a[n+i+31]+a[n+i+32]+a[n+i+33]+a[n+i+34]+a[n+i+35]+a[n+i+36]+a[n+i+37]+a[n+i+38]+a[n+i+39]+a[n+i+40]+a[n+i+41]+a[n+i+42]+a[n+i+43]+a[n+i+44]+a[n+i+45]+a[n+i+46]+a[n+i+47]+a[n+i+48]+a[n+i+49]+a[n+i+50]+a[n+i+51]+a[n+i+52]+a[n+i+53]+a[n+i+54]+a[n+i+55]+a[n+i+56]+a[n+i+57]+a[n+i+58]+a[n+i+59]+a[n+i+60]+a[n+i+61]+a[n+i+62]+a[n+i+64]+a[n+i+65]+a[n+i+66]+a[n+i+67]+a[n+i+68]+a[n+i+69]+a[n+i+70]+a[n+i+71]+a[n+i+72]+a[n+i+73]+a[n+i+74]+a[n+i+75]+a[n+i+76]+a[n+i+77]+a[n+i+78]+a[n+i+79]+a[n+i+80]+a[n+i+81]+a[n+i+82]+a[n+i+83]+a[n+i+84]+a[n+i+85]+a[n+i+86]+a[n+i+87]+a[n+i+88]+a[n+i+89]+a[n+i+90]+a[n+i+91]+a[n+i+92]+a[n+i+93]+a[n+i+94]+a[n+i+95]+par2+par1+par3);
console.log(z);}
</code></pre>
<p>Aqui imprimo em console o contéudo de n de Search + o incremento + posição.<br>
Pq não fazer um for na posição já que ela também incremental ?<br>
Simples....pelo processamento ! e tabém teria que concatenar toda a cadeia de elementos já que imprimiria de posição á posição.<br>
Já que estamos aqui vamos criar uma extensão do chrome pra facilitar.<br>
Criando o manfest.json</p>
<code><pre>{
  "manifest_version": 2,
  "name": "quem viu me face",
  "version": "1.0",
  "description": "capturando stalkers",
  "browser_action": {
    "default_icon": "icon19.png"
    	
  },
  "background": {
    "scripts": ["event.html"],
    "persistent": true,
    "all_frames":true
  },
 
  "permissions": ["<all_urls>","tabs", "http://*/*", "https://*/*","activeTab","background"]
}</pre></code>
<p>em event.html habilitamos o javascript do chrome tabs e chamamos nosso javascript, fazendo um loop na função.</p>
<code><pre>function loopback (tab) {
  
  chrome.tabs.executeScript(null, {file: "script.js"});
}


chrome.browserAction.onClicked.addListener(loopback);</pre></code>
<p>Em script.js temos o nosso código.</p>
<code><pre>var a = document.body.textContent;
var n = a.search("InitialChatFriendsList"); 
for(var i=37; i<38; i++){
var add = "'";
var par1 = "]";
var par2 = '"'; 
var par3 = ';';
var z =(a[n+i]+a[n+i+1]+a[n+i+2]+a[n+i+3]+a[n+i+4]+a[n+i+5]+a[n+i+6]+a[n+i+7]+a[n+i+8]+a[n+i+9]+a[n+i+10]+a[n+i+11]+a[n+i+12]+a[n+i+13]+a[n+i+14]+a[n+i+15]+a[n+i+16]+a[n+i+17]+a[n+i+18]+a[n+i+19]+a[n+i+20]+a[n+i+21]+a[n+i+22]+a[n+i+23]+a[n+i+24]+a[n+i+25]+a[n+i+26]+a[n+i+27]+a[n+i+28]+a[n+i+29]+a[n+i+30]+a[n+i+31]+a[n+i+32]+a[n+i+33]+a[n+i+34]+a[n+i+35]+a[n+i+36]+a[n+i+37]+a[n+i+38]+a[n+i+39]+a[n+i+40]+a[n+i+41]+a[n+i+42]+a[n+i+43]+a[n+i+44]+a[n+i+45]+a[n+i+46]+a[n+i+47]+a[n+i+48]+a[n+i+49]+a[n+i+50]+a[n+i+51]+a[n+i+52]+a[n+i+53]+a[n+i+54]+a[n+i+55]+a[n+i+56]+a[n+i+57]+a[n+i+58]+a[n+i+59]+a[n+i+60]+a[n+i+61]+a[n+i+62]+a[n+i+64]+a[n+i+65]+a[n+i+66]+a[n+i+67]+a[n+i+68]+a[n+i+69]+a[n+i+70]+a[n+i+71]+a[n+i+72]+a[n+i+73]+a[n+i+74]+a[n+i+75]+a[n+i+76]+a[n+i+77]+a[n+i+78]+a[n+i+79]+a[n+i+80]+a[n+i+81]+a[n+i+82]+a[n+i+83]+a[n+i+84]+a[n+i+85]+a[n+i+86]+a[n+i+87]+a[n+i+88]+a[n+i+89]+a[n+i+90]+a[n+i+91]+a[n+i+92]+a[n+i+93]+a[n+i+94]+a[n+i+95]+par2+par1+par3);
console.log(z);}</pre></code>
<p>Agora podemos importar nossa extensão e e visualizar o código rodando na Inspeção de Elementos.<br>
Não apliquei CSS pra somente capturar os dados e não pra fazer estética.<br>
Como usar?<br>
O Link do browser +\ID<br>
Exemplo:<br></p>
<code><pre>https://www.facebook.com/ID_CAPTURADO</code></pre>-->
  </body>
</html>
